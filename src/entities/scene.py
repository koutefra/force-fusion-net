from dataclasses import dataclass
from entities.vector2d import Point2D, Acceleration, Velocity
from entities.frame import Frame
from entities.frame_object import PersonInFrame

@dataclass(frozen=True)
class Scene:
    id: int
    focus_person_ids: list[int] 
    goal_positions: dict[int, Point2D]
    fps: float
    frames: list[Frame]
    tag: list[int]
    dataset: str

    def calculate_delta_time(self, frame_cur_id: int):
        if frame_cur_id < 1 or frame_cur_id >= len(self.frames):
            raise ValueError(f"Invalid frame index {frame_cur_id}")
        return (self.frames[frame_cur_id].number - self.frames[frame_cur_id - 1].number) / self.fps

    def simulate_trajectory(self, predict_force_func: callable[[Frame, int, Point2D], Acceleration]) -> list[PersonInFrame]:
        trajectory = []
        person = next(
            o for o in self.frames[0].frame_objects if isinstance(o, PersonInFrame) and o.id == self.focus_person_id
        )
        for frame_cur_id in range(len(self.frames)):
            adjusted_frame = self.frames[frame_cur_id].transform_object(person)
            pred_acc = predict_force_func(adjusted_frame, self.focus_person_id, self.focus_person_goal)

            person = PersonInFrame(
                id=person.id,
                position=person.position,
                velocity=person.velocity,
                acceleration=pred_acc
            )
            trajectory.append(person)

            if frame_cur_id < len(self.frames) - 1:
                delta_time = self.calculate_delta_time(frame_cur_id + 1)
                person = PersonInFrame(
                    id=person.id,
                    position=person.position + person.velocity * delta_time,
                    velocity=person.velocity + person.acceleration * delta_time,
                    acceleration=Acceleration.zero()  # placeholder for next iteration
                )

        return trajectory

    @property
    def bounding_box(self) -> tuple[Point2D, Point2D]:
        x_min, y_min = float("inf"), float("inf")
        x_max, y_max = float("-inf"), float("-inf")
        
        for frame in self.frames:
            for frame_obj in frame.frame_objects:
                pos = frame_obj.position
                x_min, y_min = min(x_min, pos.x), min(y_min, pos.y)
                x_max, y_max = max(x_max, pos.x), max(y_max, pos.y)
        
        return Point2D(x=x_min, y=y_min), Point2D(x=x_max, y=y_max)

Scenes = dict[int, Scene]



# generated by GPT
# def simulate_trajectory(self, predict_force_func: callable[[Frame, int, Point2D], Acceleration]) -> dict[int, list[PersonInFrame]]:
#     trajectories = {focus_person_id: [] for focus_person_id in self.focus_person_ids}
    
#     # Initialize each focus person from the first frame
#     initial_persons = {
#         focus_person_id: next(
#             o for o in self.frames[0].frame_objects if isinstance(o, PersonInFrame) and o.id == focus_person_id
#         )
#         for focus_person_id in self.focus_person_ids
#     }

#     for frame_cur_id in range(len(self.frames)):
#         for focus_person_id in self.focus_person_ids:
#             person = initial_persons[focus_person_id]
#             goal_position = self.goal_positions[focus_person_id]
            
#             # Transform the frame to adjust any necessary object parameters
#             adjusted_frame = self.frames[frame_cur_id].transform_object(person)
            
#             # Predict acceleration based on the current frame, person, and goal
#             pred_acc = predict_force_func(adjusted_frame, focus_person_id, goal_position)
            
#             # Create the updated PersonInFrame object
#             person = PersonInFrame(
#                 id=person.id,
#                 position=person.position,
#                 velocity=person.velocity,
#                 acceleration=pred_acc
#             )
#             trajectories[focus_person_id].append(person)
            
#             # Update position and velocity for the next frame
#             if frame_cur_id < len(self.frames) - 1:
#                 delta_time = self.calculate_delta_time(frame_cur_id + 1)
#                 person = PersonInFrame(
#                     id=person.id,
#                     position=person.position + person.velocity * delta_time,
#                     velocity=person.velocity + person.acceleration * delta_time,
#                     acceleration=Acceleration.zero()  # reset for next iteration
#                 )
#                 # Update the initial_persons for the next frame
#                 initial_persons[focus_person_id] = person

#     return trajectories
